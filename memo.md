> winterrain1127.github.io

# 깃허브 블로그 생성 시 주의사항
- username.github.io의 형식으로 생성
- username에는 Github username과 동일해야 함.
  - Github username이 'user1127'이고, repository name이 'winterrain1127.github.io'이라면
    __'user1127.github.io/winterrain1127.github.io'으로 접속__ 해야 함
  - Github username이 'winterrain1127'이고, repository name이 'winterrain1127.github.io'이라면  
    __'winterrain1127.github.io'으로 접속__ 됨.

# Commit
  개발 중 뼈대 작성, 버그 수정, 기능 추가 등 변경사항에 대한 작업이력을 기록하는 것을 의미한다.  
  시간 순으로 저장되며 현재까지 진행된 작업 진행 상황을 파악하기에 용이하다.

  ## 좋은 Commit이란?
  ### 커밋 메세지만 봐도 이해가 쉽게
  커밋에는 메모를 작성할 수 있으며, 명료하고 이해하기 쉽게 남기는 것이 좋다.  
  의미가 있는 업데이트를 작업사항 별로 구분하여 메모를 작성하면 이력만을 보고 변경 내용을 찾기 쉽다.   
  또한 다른 사람의 커밋 로그를 이해하고 확인하는 것이 빠르다.  
  더 쉬운 유지보수, 더 나은 협업과 리뷰, 더 좋은 가독성을 위한 것이다!

  ### - commit을 쪼개서 작업하는 이유
  결국 커밋도 사람이 읽기 쉽게 해야하는 것이다.  
  한 번에 여러 수정사항이 있는 커밋보다 잘게 쪼갠 커밋이 각 역할을 하나하나 확인하기가 쉽다.  
  메세지만 보고도 어떤 파일들이 변경되었는지 추측이 가능해야한다.

  ### - git add
  > 작업의 변경내용을 "스테이징" 영역에 추가하는 명령어

  팀원과 협업할 경우 어떤 업무를 Update했는지 명확하게 표현할 수 있는 Commit을 남길 것.  
  커밋 메세지는 어떻게 변경하였는지 보다 무엇을, 왜 변경했는지를 간단히 적는 것이 좋다.

  ## Convention
  ### 협업을 위해 일관성있게 작성하는 원칙과 규칙
  가독성을 높이고 유지보수를 위한 공통의 약속으로 정하는 것

  ### commit convention
  ### commit message에 대한 약속
  커밋의 내용은 새 기능 추가, 버그 수정, 디자인의 변경, 리팩토링, 포맷 변경, 이름 변경 ... 등등등 다양한 수정사항들이 적히게 될 것이다. 함께 협업하는 사람들이 detail하게 메세지를 적어도 정해진 양식이나 규칙이 존재하지 않으면 가독성이 떨어질 것이다.  
  그렇기에 동일한 레이아웃으로 커밋을 작성하면 보기에도 편하고 찾기가 쉬울 것이다. 협업할 때 다른 동료가 무엇을 수정했는지를 파악하기 쉬울 것 같다. 또한 나중에는 배포 프로세스를 정할 수 있는 기준이 된다.

  ### Commit type
  __Feat:__ 새로운 기능 추가  
  __Fix:__ 버그 수정 또는 typo  
  __Refactor:__ 리팩토링  
  __Design:__ CSS 등 사용자 UI 디자인 변경  
  __Comment:__ 필요한 주석 추가 및 변경  
  __Style:__ 코드 포맷팅, 세미콜론 누락, 코드 변경이 없는 경우  
  __Test:__ 테스트(테스트 코드 추가, 수정, 삭제, 비지니스 로직에 변경이 없는 경우)  
  __Chore:__ 위에 걸리지 않는 기타 변경사항(빌드 스크립트 수정, assets image, 패키지 매니저 등)  
  __Init:__ 프로젝트 초기 생성  
  __Rename:__ 파일 혹은 폴더명 수정하거나 옮기는 경우  
  __Remove:__ 파일을 삭제하는 작업만 수행하는 경우  

  ## Push
  ### Push의 역할
  ### git commit
  커밋은 로컬 저장소(clone 을 통해 내 컴퓨터에 복제된 원격 저장소의 복사본)에 변경 이력을 남기는 것이었다.  
  그렇기에 복사본에서 아무리 작업해도 본래의 원격 저장소는 변경사항을 알 수가 없기에 이 사항을 넘겨줘야하는데 그 때 사용하는 명령어가 바로 __git push__ 이다!  
  
  `git push <저장소명> <브랜치명>`  

  푸시를 날려주면, 그 동안 로컬 저장소에서 작업했던 내용이 원격 저장소에 전송이 되는 것이다.  
  원격 저장소에 올리기 전에는 내 컴퓨터에서만 벌어지는 일이기 때문에 문제가 발생하지 않지만 원격 저장소에 올린 이후부터는 함부로 변경이력을 수정하면 문제가 발생할 수 있다. 동료와 동시에 코드 변경 이력을 업데이트하면
코드 충돌이 발생할 수 있기 때문이다! 그렇기에 원격 저장소에 올린 코드는 덮어쓰지 않는 것이 원칙이다.

  ## Branch
  본 환경의 복사본(branch)를 만들어 독립적으로 작업을 진행하고 저장할 수 있는 작업환경

  ### 브랜치를 사용하는 이유
  - 독립적으로 관리하기 위해서
  - 안정적인 개발환경 유지 (기존의 안정적인 코드와 현재 작업중인 환경을 구분해서 관리가 가능함)

  ### 협업 과정에서의 Branch
  - 메인 브랜치에는 직접 커밋하지 않으며 이는 동시에 하다 생길 수 있는 이슈들을 방지하기 위해서이다.  
    그렇기에 해당 브랜치에서의 개발이 끝난다면 이 브랜치에 작업 내용을 푸시하고 메인 브랜치와 병합한다.
    
  ### 브랜치 이동
  `git checkout <이동할 브랜치 이름>`
  
  ### 브랜치 로그
  ```
  git log
  --graph : 브랜치의 흐름을 같이 출력
  -- all : 모든 브랜치 로그 출력
  ```

  ## git stash
  아직 마무리하지 않은 작업을 스택에 잠시 저장하는 명령어. 완료되지 않은 일을 commit하지 않고 다시 꺼내와 마무리할 수 있음.  
  일종의 임시저장 개념.  
  
  ![Alt text](https://velog.velcdn.com/images/spolice/post/7988b21e-1550-4ef1-bfe2-9e372fb950f4/image.png)
  
  __stash란 아래에 해당하는 파일을 보관하는 장소__ 이다.


  #### 1) Modified 면서 tracked 상태의 파일
  - 여기서 modified란?
    파일에 수정사항이 있는 경우를 의미한다.
  
  - 여기서 tracked란?
  깃은 한 번이라도 커밋을 한 파일의 수정 여부를 계속해서 추적하게 되는데 이처럼 깃이 추적하고 있는 파일을 tracked 파일이라고 한다.
  
  - 그렇다면 untracked는?
  예를 들어 파일을 새로 만들었을 때 Untracked files 라는 표시가 뜬다. 이 파일은 한 번도 깃에서 버전 관리를 하지 않았기 때문에 수정 내역을 추적하지 않았다. 이럴 경우 untracked 파일이라고 한다.

  #### 2) Staging area 에 있는 파일
  ##### 1. Git Stash
  __git stash__  
  위의 명령어를 통해 새로운 stash를 스택에 만들어 변경사항을 임시로 저장한다.
  
  ##### 2. Stash 확인하기
  __git stash list__  
  여러번 stash 했을 때 위의 명령어를 통해 저장한 stash 목록을 확인 가능하다.
  
  ##### 3. Stash 했던 작업을 다시 가져오기
  __git stash apply__  
  위의 명령어를 통해 했던 작업을 다시 가져온다.
  ```
  //가장 최근의 stash를 가져와 적용
  git stash apply
  //원하는 stash를 불러와 적용
  git stash apply [stash 이름]
  ```
  __git stash drop__  
  apply 옵션을 통해 stash를 적용했다면 적용한 stash는 여전히 스택에 남아있다.  
  스택에 남아있는 stash를 제거하기 위해서는 drop 명령어를 사용한다.  

  방법은 stash와 같다!  

  __git stash pop__  
  (apply + drop의 형태이다!)  
  이렇게 저장한 임시 변경사항을 꺼내오는 명령어  
  스택처럼 동작함. 가장 최근에 저장한 변경 사항을 꺼냄  

  #### git cherry-pick
  ##### git cherry-pick
  두 개의 브랜치가 있다고 가정할 때, 현재 개발하고 있는 브랜치에서 다른 브랜치에 적용되어 있는 3개의 커밋을 가져와 반영시키고 싶은 상황이다. 이럴 때 사용하는 명령어이다.

  `git cherry-pick <commit hash>`

  이런 식으로 cherry-pick 명령 뒤에 커밋 해시 값을 명시해줘야한당 한번에 여러개 하고 싶으면 여러개 연달아서 뒤쪽에 입력해도 됨.

  `git cherry-pick <commit hash>..<commit hash>`

  이런 식으로 가져오고 싶은 범위의 첫번째와 마지막 해시값을 ..로 이어 표현해도 된다. 이러면 이 사이에 있는 모든 커밋들을 가져와 현재 브랜치에 반영할 수 있다. ( 첫번째 값은 반영이 안됨, 그 다음부터 마지막 커밋까지 반영)  

  다른 브랜치의 커밋사항을 가져오는 명령어이기 때문에 수정사항이 현재 브랜치의 코드에 맞지 않는 경우가 있다.
  이 경우 충돌이 발생하게 되는데 cherry-pick 을 포기하거나 해결하고 다시 진행할 수도 있다.

  ```
  vi $file_path # 파일 수정
  git add $file_path
  git cherry-pick -continue
  ```

  충돌이 발생한 코드를 에디터로 열어 수정하는 명령어이다.
  git add 로 수정된 코드를 추가 후 cherry-pick -continue 명령을 실행하면 충돌을 수정한 코드를 반영, 재개 한다.

  ```
  git cherry-pick -abort
  ```

  만약 cherry-pick 을 중단하고 싶으면 -abort 옵션을 이용하여 중단할 수 있다.
  cherry-pick 실행하기전 상황으로 코드가 돌아간다.

  ## git fetch
  원격 저장소에 있는 변경사항들을 로컬 저장소에 가져오기 전에 변경 내용을 확인하고 싶은 경우 사용하는 명령어이다.  

  이해하기 좋은 예시가 있어 참고하자면...

  > 만약 내가 작업한 파일을 깃허브에 올리고 퇴근했다. 근데 다음날 누군가 내 파일에 다른 변경사항을 남겼는지 확인하고 싶을 때!
    로컬 디렉토리로 변경한 내용을 가져오지 않고 변경한 내역들만 확인할 때 사용한다.

  ### pull 과의 차이점
  pull은 원격 저장소의 내용을 가져와 자동으로 병합작업을 실행한다. 하지만 내용을 확인만 하고 로컬 데이터와의 병합을 원치 않는 경우 fetch를 사용하면 된다.

  __fetch + merge => pull__
  그렇다면 merge 란?

  ## git merge
  git merge 란 브랜치를 다른 브랜치로 합치는 과정을 의미한다.  
  예를 들어 coding-test 라는 브랜치에서 문제풀이를 업데이트했고, 문제 사항이 없는 경우 메인 브랜치에 업데이트를 하는 방식으로 과제를 저장하고 있다. 이 경우, 이 둘을 병합시키는 과정이 merge인 것이다.

  ## git rebase
  git rebase 도 역시 브랜치를 다른 브랜치로 합치는 과정을 의미한다.  
  그렇다면 merge와의 차이점이 무엇인가?

  ### git merge 와 git rebase의 차이점
  git 에서 merge와 rebase 의 실행결과는 같다, 하지만 커밋 스토리가 달라진다.  
  Merge의 경우 합쳐진 브랜치의 커밋 메세지가 중복으로 쌓이며 커밋 순서를 바꾸지 않는다.  

  ![Alt text](https://velog.velcdn.com/images/spolice/post/e993f88f-fc5b-4d55-ba8d-a8627b8234ad/image.png)  
  이 이미지의 경우 main 브랜치에 feature 브랜치를 병합하는 과정을 나타냈으며 커밋의 순서는 변경 되지 않고 기존의 것들은 유지되고 있는 모습이다.  

  ![Alt text](https://velog.velcdn.com/images/spolice/post/e67a6d3a-28b4-4641-baf2-c5928670af93/image.png)  
  git rebase를 이용한 feature 브랜치를 main 브랜치에 병합하는 이미지이다.  
  feature 브랜치의 커밋은 Main 브랜치가 가지고 있던 기존의 커밋 뒤에 위치하게 된다.  
  병합을 하면 브랜치의 커밋메세지가 시간 순서대로 합쳐져 히스토리를 깔끔하게 유지하고 싶을 때 사용하면 된다. 즉, master 브랜치의 기존의 마지막 커밋 뒤에 병합할 브랜치의 커밋들을 합쳐지게 하여 master 브랜치에 재배치(rebase)를 하는 것을 의미한다.  

  #### pick
  커밋을 사용하겠다는 의미, 이를 이용해 커밋의 순서를 바꿀 수 있고, 커밋의 해시값을 이용해 특정 커밋을 가져올 수 있습니다.
  - rebase 명령어를 실행하면 기본적으로 pick으로 설정돼있기 때문에 아무것도 변경하지 않고 종료한다면, 커밋에 대하여 어떠한 변경도 일어나지 않게 됩니다.
  - 위 코드에서 commit2와 commit3의 순서를 바꾼다면, 커밋 순서와 커밋 해시값까지 변경됩니다.
    
  #### reword
  - 커밋 메시지를 변경하는 명령어
  - 커밋 메시지를 변경할 커밋 앞에 reword 명령으로 수정하고, 저장하면 해당 커밋의 메시지를 다시 작성하는 에디터 창이 열리게 됩니다.
  - 커밋 메시지와 커밋의 해시값 또한 변경됩니다.

  ### edit
  - reword 명령어는 커밋 메시지만 변경하는 명령이라면, edit 명령어는 커밋 메시지뿐만 아니라 커밋의 작업 내용까지 변경할 수 있습니다.
  - commit4라는 커밋을 edit으로 바꾸고 저장 후 종료하면, 변경할 커밋으로 checkout됨, 그 상태에서 변경 작업을 수행하면 됩니다.
  - 그 후 변경사항을 저장하기 위해 아래와 같은 명령어 입력

  ### squash
  - squash 명령어는 해당 커밋을 이전 커밋과 합치는 명령어입니다.

  > _**주의 사항**_  
  그렇기에 이전의 커밋 히스토리를 시간 순서대로 배열하는 과정에서 변경사항들이 생기기 때문에 주의를 요한다.  
  만약, 이미 원격 저장소에 푸시한 커밋이라면, 변경한 커밋들은 원격 저장소에 푸시 되지 않을 것이다. 명령어를 사용하여 ( git push --force , git push -f ) 강제로 히스토리를 덮어쓸 수 있지만 커밋 히스토리 불일치가 발생하면 깃이 꼬일 것...

<br/>
<br/>
<br/>
<br/>  

----  
출처  
https://data-scientist-techlog.tistory.com/entry/Githubio-%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A5%BC-%EB%A7%8C%EB%93%A4%EC%96%B4%EB%B3%B4%EC%9E%90-githubio-%EB%B8%94%EB%A1%9C%EA%B7%B8%EB%A7%8C%EB%93%A4%EA%B8%B0-1%ED%8E%B8  
https://velog.io/@spolice/Git-Github-%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC  
https://velog.io/@spolice/Git-Github-%ED%95%99%EC%8A%B5-%EB%82%B4%EC%9A%A9-%EC%A0%95%EB%A6%AC-2
